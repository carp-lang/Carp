(doc Dynamic "This module contains dynamic functions which are used in the Carp repl and during compilation. They are not available in compiled code. Read more about dynamic functions in the [Language Guide](https://github.com/carp-lang/Carp/blob/master/docs/LanguageGuide.md#dynamic-functions).")

(defmodule Dynamic
  ;; Functions for doing things at the REPL and during compile time.

  (doc nil "is the value `nil`, i.e. the empty list.")
  (defdynamic nil '())

  (doc nil? "checks whether a value is nil, i.e. the empty list.")
  (defndynamic nil? [value]
    (= value nil))

  (defndynamic inc [x]
    (+ x 1))

  (defndynamic dec [x]
    (- x 1))

  (defndynamic neg [x]
    (* -1 x))

  (defndynamic mod [x y]
    (let-do [a (if (< x 0) (neg x) x)
             b (if (< y 0) (neg y) y)
             m a]
      (while (or (> m b) (= m b))
        (set! m (- m b)))
      (if (< a 0) (neg m) m)))

  (doc imod "implements the modulo on integers, and is much faster than
[`mod](#mod).")
  (defndynamic imod [x y]
    (- x (* y (/ x y))))

  (doc even? "checks whether the number `n` is even.")
  (defndynamic even? [n] (= 0 (mod n 2)))

  (doc odd? "checks whether the number `n` is odd.")
  (defndynamic odd? [n] (= 1 (mod n 2)))

  (defmodule Project
    (doc no-echo "Turn off debug printing in the compiler.")
    (defndynamic no-echo []
      (do
        (Project.config "print-ast" false)
        (Project.config "echo-compiler-cmd" false))))

  (defmodule String
    (defndynamic prefix [s to]
      (String.slice s 0 to))

    (defndynamic suffix [s from]
      (String.slice s from (String.length s)))

    (defndynamic starts-with? [s prfx]
      (= (String.prefix s (String.length prfx)) prfx))

    (defndynamic ends-with? [s prfx]
      (= (String.suffix s (String.length prfx)) prfx))

    (defndynamic head [s]
      (String.prefix s 1))

    (defndynamic tail [s]
      (String.suffix s 1))
  )

  (hidden dynamic-type-tag)
  (defdynamic dynamic-type-tag "carp-dynamic-type-tag-")

  (doc deftype-dynamic "creates a dynamic type with the members `slots` under
the name `name`.

Getters, setters, and initializers will be created.

Example:
```
(deftype-dynamic Point (x y))

(Point.str (Point.set-y (Point.init 1 2) 4))
; => \"(Point 1 4)\"
```")
  (defmacro deftype-dynamic [name slots]
    (eval `(defmodule %name
       (defndynamic init %(collect-into slots array)
          [%(String.concat [dynamic-type-tag (Symbol.str name)]) %@slots])

       (defndynamic %(Symbol.concat [name '?]) [o]
         (and (array? o) (= (car o) '%(String.concat [dynamic-type-tag (Symbol.str name)]))))

       %@(map
           (fn [slot]
             `(defndynamic %slot [o]
                 (List.nth o %(inc (List.index-of slots slot)))))
           slots)

       %@(map
           (fn [slot]
             `(defndynamic %(Symbol.concat ['set- slot]) [o n]
                 (List.set-nth o %(inc (List.index-of slots slot)) n)))
           slots)

      (defndynamic str [o]
        (String.concat
          ["(" %(Symbol.str name)
               %@(map (fn [slot] `(String.concat [" " (str (%(Symbol.prefix name slot) o))])) slots)
           ")"]))
    ))
  )

  ; this is sadly too slow :(
  ;(defdynamic prim-= =)

  ;(defndynamic = [a b]
  ;  (if (and (array? a) (not (empty? a)))
  ;    (let [tag? (car a)
  ;          s (str tag?)
  ;          cs (str dynamic-type-tag)]
  ;      (if (and (symbol? tag?) (String.starts-with? s cs))
  ;        (let [md (String.suffix s (length cs))
  ;              f (Symbol.prefix (Symbol.from md) '=)]
  ;          ((eval f) a b))
  ;        (prim-= a b)))
  ;    (prim-= a b)))

  (hidden prim-str)
  (defdynamic prim-str str)

  (defndynamic str [a]
    (if (and (array? a) (not (empty? a)))
      (let [tag? (car a)
            cs (prim-str dynamic-type-tag)]
        (if (and (string? tag?) (String.starts-with? tag? cs))
          (let [md (String.suffix tag? (String.length cs))
                f (Symbol.prefix (Symbol.from md) 'str)]
            ((eval f) a))
          (prim-str a)))
      (prim-str a)))
)


;; The following functions are not put into a module for now:

(defndynamic add-cflag [flag]
  (eval (list 'Project.config "cflag" flag)))

(defndynamic add-lib [lib]
  (eval (list 'Project.config "libflag" lib)))

(defndynamic pkg-config [pkg flags]
  (Dynamic.String.concat (Dynamic.append
                          (Dynamic.append
                           ["`pkg-config " pkg " "]
                           (Project.get-config "pkgconfigflag")
                           )
                          [flags "`"])))

(defndynamic add-pkg [pkg]
  (do
    (add-cflag (pkg-config pkg "--cflags"))
    (add-lib (pkg-config pkg "--libs"))))

(defndynamic current-file []
  (car (Project.get-config "load-stack")))

(defndynamic relative-to [path relpath]
  (Dynamic.String.concat [(Dynamic.Path.directory path)
                          "/"
                          relpath]))

(defndynamic add-c [relpath]
  (Project.config "cmod" (relative-to (current-file) relpath)))
