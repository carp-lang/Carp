(defndynamic thread-first-internal [xs]
  (if (= (length xs) 2)
    (if (list? (last xs))
      (cons (caadr xs)
            (cons (car xs)
                  (cdadr xs)))
      (list (cadr xs) (car xs)))
    (if (list? (last xs))
      (append
       (list
        (car (last xs))
        (thread-first-internal (all-but-last xs)))
       (cdr (last xs)))
      (list (last xs) (thread-first-internal (all-but-last xs))))))

(defndynamic thread-last-internal [xs]
  (if (= (length xs) 2)
    (if (list? (last xs))
      (cons-last (car xs) (last xs))
      (list (cadr xs) (car xs)))
    (if (list? (last xs))
      (cons-last (thread-last-internal (all-but-last xs)) (last xs))
      (list (last xs) (thread-last-internal (all-but-last xs))))))

(defmacro => [:rest forms]
  (thread-first-internal forms))

(defmacro ==> [:rest forms]
  (thread-last-internal forms))

(defmacro when [condition form]
  (list 'if condition form (list)))

(defmacro unless [condition form]
  (list 'if condition (list) form))

(defndynamic case-internal [name xs]
  (if (= (length xs) 0)
    (list)
    (if (= (length xs) 2)
      (macro-error "case has even number of branches; add an else branch")
      (if (= (length xs) 1)
        (car xs)
        (list 'if
         (list '= name (car xs))
          (cadr xs)
          (case-internal name (cddr xs)))))))

(defmacro case [name :rest forms]
  (case-internal name forms))

(defndynamic comp-internal [sym fns]
  (if (= (length fns) 0)
    sym
    (list (car fns) (comp-internal sym (cdr fns)))))

(doc comp "Composes the functions `fns` into one `fn`.")
(defmacro comp [:rest fns]
  (let [x (gensym)]
    (list 'fn [x] (comp-internal x fns))))

(doc doto
     "Evaluates `thing`, then calls all of the functions on it and"
     "returns it. Useful for chaining mutating, imperative functions, and thus"
     "similar to `->`. If you need `thing` to be passed as a `ref` into `expressions`"
     "functions, use [`doto-ref`](#doto-ref) instead."
     ""
     "```"
     "(let [x @\"hi\"]"
     "  @(doto &x"
     "    (string-set! 0 \o)"
     "    (string-set! 1 \y)))"
     "```")
(defmacro doto [thing :rest expressions]
  (let [s (gensym)]
    (list 'let [s thing]
      (cons-last
        s
        (cons 'do (map (fn [expr] (cons (car expr) (cons s (cdr expr)))) expressions))))))

(doc doto-ref
     "Evaluates `thing`, then calls all of the functions on it and"
     "returns it. Useful for chaining mutating, imperative functions, and thus"
     "similar to `->`. If you need `thing` not to be passed as a `ref` into"
     "`expressions` functions, use [`doto`](#doto) instead."
     ""
     "```"
     "(doto-ref @\"hi\""
     "  (string-set! 0 \o)"
     "  (string-set! 1 \y))"
     "```")
(defmacro doto-ref [thing :rest expressions]
  (let [s (gensym)]
    (list 'let [s thing]
      (cons-last
        s
        (cons 'do
          (map (fn [expr] (cons (car expr) (cons (list 'ref s) (cdr expr))))
          expressions))))))
