;; A slightly bigger example of how to work with structs and arrays that change

(use IO)

(deftype Pos
    [x Float
     y Float])

(defn incf [x]
  (Float.+ x 1.0f))

(defmodule Pos
  (defn move [pos]
    (=> pos
        (Pos.update-x incf)
        (Pos.update-y incf))))

(deftype Monster
    [pos Pos
     hp Int
     name String])

(defmodule Monster
  (defn move [monster]
    (Monster.update-pos monster Pos.move)))

(defn main []
  (do
    ;; TODO: Go back to old code that used random generation and 'copy-map'.
    (let [monsters [(Monster.init (Pos.init 22.4f  84.7f) 100 @"Pegasus")
                    (Monster.init (Pos.init 1.0f  110.9f) 100 @"Dragon")
                    (Monster.init (Pos.init 0.4f   36.0f) 100 @"Devil")]]
      (do
        (println (ref (Array.str &monsters)))
        (let [new-monsters (Array.endo-map Monster.move monsters)]
          (println (ref (Array.str &new-monsters))))))

    0 ;; <- Return value, should not be needed?!

    ))
