(defn re_sub [pattern sdata]		; not suitable for all valid patterns, merely to give an example
  (let-do [loop-res  (Maybe.Nothing)
           alltexts (Pattern.split        pattern sdata) 
           matches  (Pattern.global-match pattern sdata) 
           texts    (Array.rest &alltexts) 
           result   (Maybe.unsafe-from (Array.first &alltexts)) ]
    (while (Maybe.nothing? &loop-res)
      (if (Array.empty? &matches)

;        (set! loop-res (Maybe.Just (String.copy &result)))	; debug: this works 
        (set! loop-res (Maybe.Just result))					; debug: this is rejected by the compiler

        (let-do [cur-match (Array.unsafe-first (Array.unsafe-first &matches))	; quick & dirty
                 cur-text  (Array.unsafe-first &texts)
                 new-match (if (String.starts-with? cur-match "ignore:") 
                             cur-match 
                             &(String.ascii-to-upper cur-match) )]
          (set! matches (Array.rest &matches))
          (set! texts   (Array.rest &texts))
	      (set! result  (fmt "%s%s%s" &result new-match cur-text)) )))
        (Maybe.or-zero loop-res) ))
	
(defn main []
  (let [p #"'.-'"
        d "Whatever we 'do' is going to cause some 'trouble' no matter how 'ignore:hard' we try" ]
	(IO.println &(re_sub p d)) ))